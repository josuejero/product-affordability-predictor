
File: ./deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: web
        image: my-django-app:latest
        ports:
        - containerPort: 8000
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 10

File: ./Dockerfile
FROM python:3.9

WORKDIR /app

COPY requirements.txt /app/
RUN pip install -r requirements.txt

RUN pip install gunicorn

COPY . /app/

EXPOSE 8000

CMD ["gunicorn", "--bind", "0.0.0.0:8000", "pap.wsgi:application"]

File: ./pap/pap/asgi.py
import os
from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'pap.settings')

application = get_asgi_application()

File: ./pap/pap/settings.py
import os
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = os.getenv('SECRET_KEY')

DEBUG = os.getenv('DEBUG', 'False') == 'True'

ALLOWED_HOSTS = []

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'myapp',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'pap.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'pap.wsgi.application'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

STATIC_URL = '/static/'

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

File: ./pap/pap/urls.py
from django.contrib import admin
from django.urls import path

urlpatterns = [
    path('admin/', admin.site.urls),
]

File: ./pap/pap/wsgi.py
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'pap.settings')

application = get_wsgi_application()

File: ./pap/myapp/models.py
from django.db import models

class Cashflow(models.Model):
    date = models.DateField()
    income = models.DecimalField(max_digits=10, decimal_places=2)
    expenses = models.DecimalField(max_digits=10, decimal_places=2)

    def __str__(self):
        return f"Cashflow on {self.date}"

class Product(models.Model):
    name = models.CharField(max_length=255)
    price = models.DecimalField(max_digits=10, decimal_places=2)

    def __str__(self):
        return self.name

class AffordabilityPrediction(models.Model):
    cashflow = models.ForeignKey(Cashflow, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    predicted_affordability = models.DecimalField(max_digits=10, decimal_places=2)

    def __str__(self):
        return f"{self.product.name} predicted affordability"

File: ./pap/myapp/apps.py
from django.apps import AppConfig

class MyappConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'myapp'

File: ./pap/myapp/admin.py
from django.contrib import admin
from .models import Cashflow, Product, AffordabilityPrediction

@admin.register(Cashflow)
class CashflowAdmin(admin.ModelAdmin):
    list_display = ['date', 'income', 'expenses']

@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['name', 'price']

@admin.register(AffordabilityPrediction)
class AffordabilityPredictionAdmin(admin.ModelAdmin):
    list_display = ['cashflow', 'product', 'predicted_affordability']

File: ./pap/myapp/tests.py
from django.test import TestCase
from .models import Cashflow, Product, AffordabilityPrediction
from django.urls import reverse

class CashflowModelTest(TestCase):
    def setUp(self):
        self.cashflow = Cashflow.objects.create(date='2024-01-01', income=1000, expenses=500)

    def test_cashflow_creation(self):
        self.assertEqual(self.cashflow.income, 1000)
        self.assertEqual(self.cashflow.expenses, 500)

class ProductModelTest(TestCase):
    def setUp(self):
        self.product = Product.objects.create(name='Laptop', price=1200)

    def test_product_creation(self):
        self.assertEqual(self.product.name, 'Laptop')
        self.assertEqual(self.product.price, 1200)

class AffordabilityPredictionTest(TestCase):
    def setUp(self):
        self.cashflow = Cashflow.objects.create(date='2024-01-01', income=1000, expenses=500)
        self.product = Product.objects.create(name='Laptop', price=1200)
        self.prediction = AffordabilityPrediction.objects.create(cashflow=self.cashflow, product=self.product, predicted_affordability=600)

    def test_prediction_creation(self):
        self.assertEqual(self.prediction.predicted_affordability, 600)

class CashflowViewTest(TestCase):
    def test_cashflow_list_view(self):
        response = self.client.get(reverse('cashflow_list'))
        self.assertEqual(response.status_code, 200)

class ProductViewTest(TestCase):
    def test_product_list_view(self):
        response = self.client.get(reverse('product_list'))
        self.assertEqual(response.status_code, 200)

class AffordabilityViewTest(TestCase):
    def test_affordability_predictions_view(self):
        response = self.client.get(reverse('affordability_predictions'))
        self.assertEqual(response.status_code, 200)

File: ./pap/myapp/views.py
from django.shortcuts import render
from .models import Cashflow, Product, AffordabilityPrediction

def cashflow_list(request):
    cashflows = Cashflow.objects.all()
    return render(request, 'cashflow_list.html', {'cashflows': cashflows})

def product_list(request):
    products = Product.objects.all()
    return render(request, 'product_list.html', {'products': products})

def affordability_predictions(request):
    predictions = AffordabilityPrediction.objects.all()
    return render(request, 'affordability_predictions.html', {'predictions': predictions})

File: ./pap/manage.py
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'pap.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

File: ./service.yaml
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  selector:
    app: my-app
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8000
  type: LoadBalancer

File: ./problem.py
import os

# Function to collect and write code to a file
def collect_code(output_file="all_code.txt", ignore_dir="venv"):
    with open(output_file, "w") as output:
        for root, dirs, files in os.walk("."):
            # Skip the "venv" directory
            if ignore_dir in dirs:
                dirs.remove(ignore_dir)
            
            for file in files:
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, "r") as f:
                        output.write(f"\n\n# File: {file_path}\n\n")
                        output.write(f.read())
                except (UnicodeDecodeError, IOError):
                    print(f"Skipping binary or unreadable file: {file_path}")

if __name__ == "__main__":
    collect_code()

File: ./Jenkinsfile
pipeline {
    agent any

    stages {
        stage('Build') {
            steps {
                sh 'docker build -t my-django-app .'
            }
        }
        stage('Test') {
            steps {
                sh 'python manage.py test'
            }
        }
        stage('Deploy to Staging') {
            steps {
                sh 'kubectl apply -f deployment.yaml'
                sh 'kubectl apply -f service.yaml'
            }
        }
        stage('Deploy to Production') {
            steps {
                input "Deploy to production?"
                sh 'kubectl apply -f deployment-production.yaml'
                sh 'kubectl apply -f service-production.yaml'
            }
        }
    }
}

File: ./notebooks/exploratory_data_analysis.ipynb
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "{\n",
    " \"cells\": [\n",
    "  {\n",
    "   \"cell_type\": \"code\",\n",
    "   \"execution_count\": null,\n",
    "   \"metadata\": {},\n",
    "   \"outputs\": [],\n",
    "   \"source\": [\n",
    "    \"import pandas as pd\\n\",\n",
    "    \"from model import predict_affordability\\n\",\n",
    "    \"import logging\\n\",\n",
    "    \"\\n\",\n",
    "    \"logging.basicConfig(level=logging.INFO)\\n\",\n",
    "    \"logger = logging.getLogger(__name__)\\n\",\n",
    "    \"\\n\",\n",
    "    \"cashflow = pd.read_csv('../data/cashflow.csv')\\n\",\n",
    "    \"\\n\",\n",
    "    \"cashflow['Date'] = pd.to_datetime(cashflow['Date'])\\n\",\n",
    "    \"\\n\",\n",
    "    \"logger.info(\\\"Generating predicted balances...\\\")\\n\",\n",
    "    \"predicted_balances = predict_affordability(cashflow)\\n\",\n",
    "    \"\\n\",\n",
    "    \"if predicted_balances is not None:\\n\",\n",
    "    \"    logger.info(\\\"Predicted balances successfully calculated.\\\")\\n\",\n",
    "    \"    print(predicted_balances.head())\\n\",\n",
    "    \"else:\\n\",\n",
    "    \"    logger.error(\\\"Error: Could not calculate predicted balances. Please check input data and model.\\\")\\n\",\n",
    "    \"    print(\\\"Error: Could not calculate predicted balances.\\\")\\n\"\n",
    "   ]\n",
    "  }\n",
    " ],\n",
    " \"metadata\": {\n",
    "  \"kernelspec\": {\n",
    "   \"display_name\": \"venv\",\n",
    "   \"language\": \"python\",\n",
    "   \"name\": \"python3\"\n",
    "  },\n",
    "  \"language_info\": {\n",
    "   \"codemirror_mode\": {\n",
    "    \"name\": \"ipython\",\n",
    "    \"version\": 3\n",
    "   },\n",
    "   \"file_extension\": \".py\",\n",
    "   \"mimetype\": \"text/x-python\",\n",
    "   \"name\": \"python\",\n",
    "   \"nbconvert_exporter\": \"python\",\n",
    "   \"pygments_lexer\": \"ipython3\",\n",
    "   \"version\": \"3.12.4\"\n",
    "  }\n",
    " },\n",
    " \"nbformat\": 4,\n",
    " \"nbformat_minor\": 2\n",
    "}\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "venv",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}

File: ./src/feature_engineering.py
import pandas as pd

def preprocess_data(data):
    data['Monthly Income'] = data['Income'].resample('M').sum()
    data['Monthly Expenses'] = data['Expenses'].resample('M').sum()
    data['Balance'] = data['Monthly Income'] - data['Monthly Expenses']
    return data

def feature_engineering(data):
    data['Savings Rate'] = data['Balance'] / data['Monthly Income']
    data['Projected Savings'] = data['Savings Rate'] * 12
    return data

File: ./src/analysis.py
import pandas as pd
from model import predict_affordability

def analyze_data(data):
    processed_data = preprocess_data(data)
    predicted_balances = predict_affordability(processed_data)
    
    if predicted_balances is not None:
        print("Affordability predictions:")
        print(predicted_balances.head())
    else:
        print("Error: Could not generate predictions.")

File: ./src/data_loader.py
import os
import psycopg2
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def connect_to_db():
    try:
        connection = psycopg2.connect(
            database=os.getenv('DB_NAME'),
            user=os.getenv('DB_USER'),
            password=os.getenv('DB_PASSWORD'),
            host=os.getenv('DB_HOST', 'localhost'),
            port=os.getenv('DB_PORT', '5432')
        )
        logger.info("Successfully connected to the PostgreSQL database.")
        return connection
    except psycopg2.Error as e:
        logger.error(f"Error connecting to the PostgreSQL database: {e}")
        raise

def load_data_from_db():
    conn = connect_to_db()
    cursor = conn.cursor()
    
    try:
        query = "SELECT * FROM cashflow;"
        cursor.execute(query)
        data = cursor.fetchall()
        logger.info("Data successfully loaded from the database.")
    except psycopg2.Error as e:
        logger.error(f"Error fetching data from the database: {e}")
        raise
    finally:
        cursor.close()
        conn.close()
    
    return data

def load_data(filepath=None):
    if filepath:
        logger.info(f"Loading data from {filepath}")
        return pd.read_csv(filepath)
    else:
        logger.info("Loading data from PostgreSQL database")
        return load_data_from_db()

File: ./src/model.py
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def predict_affordability(data):
    try:
        data['Predicted Affordability'] = data['Balance'] * 0.5
        logger.info("Predicted affordability successfully calculated.")
        return data[['Date', 'Predicted Affordability']]
    except Exception as e:
        logger.error(f"Error in prediction: {e}")
        return None

File: ./src/main.py
import os
import requests
import json
import logging
from data_loader import load_data
from feature_engineering import preprocess_data
from model import predict_affordability
from oauthlib.oauth2 import BackendApplicationClient
from requests_oauthlib import OAuth2Session

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

CLIENT_ID = os.getenv('CLIENT_ID')
CLIENT_SECRET = os.getenv('CLIENT_SECRET')

def get_oauth_token():
    if not CLIENT_ID or not CLIENT_SECRET:
        logger.error("OAuth credentials not set. Please set CLIENT_ID and CLIENT_SECRET.")
        raise ValueError("OAuth credentials not set.")
    
    logger.info("Fetching OAuth token...")
    client = BackendApplicationClient(client_id=CLIENT_ID)
    oauth = OAuth2Session(client=client)
    
    try:
        token = oauth.fetch_token(token_url='https://api.oauthprovider.com/token', client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
        logger.info("OAuth token fetched successfully.")
        return token
    except Exception as e:
        logger.error(f"Error fetching OAuth token: {e}")
        raise

def fetch_product_price(product_id, token):
    headers = {
        'Authorization': f"Bearer {token['access_token']}"
    }
    
    logger.info(f"Fetching product price for product ID: {product_id}")
    response = requests.get(f'https://api.products.com/products/{product_id}/price', headers=headers)
    
    if response.status_code == 200:
        logger.info("Product price fetched successfully.")
        return response.json()['price']
    else:
        logger.error(f"Failed to fetch product price. Status code: {response.status_code}")
        return None

def main():
    logger.info("Loading and preprocessing data...")
    data = load_data("data/cashflow.csv")
    processed_data = preprocess_data(data)
    
    logger.info("Predicting affordability...")
    predicted_balances = predict_affordability(processed_data)
    
    if predicted_balances is None:
        logger.error("Predicted balances not available.")
        return
    
    token = get_oauth_token()
    product_id = "12345"
    price = fetch_product_price(product_id, token)
    
    if price is not None:
        logger.info(f"Product Price: {price}")
    else:
        logger.error("Failed to fetch product price.")

if __name__ == "__main__":
    main()
